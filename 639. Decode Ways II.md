[//]: # (@Author  : xu.junpeng)
[//]: # (@Time    : 2020/7/23 11:03 下午)
## [题目链接](https://leetcode.com/problems/decode-ways-ii/)

## 思路

## 分析过程

## 存在的问题
一直没太想明白这个dp的理解方式
dp = dp[1], (one.get(s[i], 0) * dp[1] + two.get(s[i - 1: i + 1], 0) * dp[0]) % 1000000007
dp[1] 代表上一个解答，(one.get(s[i], 0) * dp[1] + two.get(s[i - 1: i + 1], 0) * dp[0]) % 1000000007 代表本次的解答
本次的解答理解为上一个情况加上一个新的字符后的解答，加入了新的字符之后，要考虑拆分为单个字符， 和合并为两个字符的情况

one.get(s[i], 0) * dp[1], 第i个字符当作单独的来看，结果为 第i个字符可以组合出来的情况 * 第i个字符前的结果集合
two.get(s[i - 1: i + 1], 0) 第i-1，i 个字符当作两个一起的字符来看，  则需要 * 第 i-1 个字符之前的结果
以'1234'为例子
1: {(1)}
12: {(1,2), (12)}
123: {(1,2,3), (12, 3)}
1234: {(1,2,3,4), (12, 3, 4)}

以'1221'为例子
1: {(1)}
12: {(1,2), (12)}
122: {(1,2,2), (12, 2), (1, 22)}

1221 : {122, 1} + {12, 21}
1221 = {(1,2,2,1), (12,2,1), (1,22,1)} + {(1,2,21), (12, 21)}

## 代码
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        one = {'1': 1, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1, '*': 9}

        two = {'10': 1, '11': 1, '12': 1, '13': 1, '14': 1, '15': 1, '16': 1, '17': 1, '18': 1, '19': 1, '20': 1,
               '21': 1,
               '22': 1, '23': 1, '24': 1, '25': 1, '26': 1, '*0': 2, '*1': 2, '*2': 2, '*3': 2, '*4': 2, '*5': 2,
               '*6': 2,
               '*7': 1, '*8': 1, '*9': 1, '1*': 9, '2*': 6, '**': 15}

        dp = 1, one.get(s[:1], 0)

        for i in range(1, len(s)):
            dp = dp[1], (one.get(s[i], 0) * dp[1] + two.get(s[i - 1: i + 1], 0) * dp[0]) % 1000000007
        return dp[-1]

```

## 结果
```

```
## 总结

